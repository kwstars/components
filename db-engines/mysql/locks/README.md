## Locks

MySQL 中有多种锁，它们在不同的粒度和场景下发挥作用，以确保数据的一致性和并发性。以下是 MySQL 中常见的锁类型：

**按锁的粒度划分：**

1. **全局锁:**：对整个数据库实例加锁。

   - **Flush Tables with Read Lock（FTWRL）**：在执行需要整个数据库一致视图的操作时使用，例如全数据库备份或逻辑导出。在此锁定期间，所有其他会话都被阻止访问数据库。
     ```sql
     FLUSH TABLES WITH READ LOCK;
     UNLOCK TABLES;
     ```

2. **表级锁**：对整张表加锁，分为以下几种：

   - **表锁（Table Locks）**：这是最基本的锁类型，可以分为读锁和写锁。读锁是共享的，允许多个事务同时读取表中的数据，但不允许写入。写锁是排他的，只允许一个事务写入数据，并阻止其他事务读取或写入数据。
   - **元数据锁（Metadata Locks，MDL）**：这种锁用于保护表的结构。当一个事务正在对表进行 DDL（数据定义语言）操作（如 ALTER TABLE）时，MySQL 会自动获取元数据锁，防止其他事务同时进行 DDL 或 DML（数据操作语言）操作。
   - **意向锁（Intention Locks）**：这种锁是在表级别上设置的，表示一个事务打算在该表的行上获取读锁或写锁。意向锁可以帮助 MySQL 更有效地管理锁冲突。
     - Intention Shared Locks (IS): 这种锁表示事务打算在表的某个部分上获取一个共享锁（S 锁）。其他事务可以同时获取该表的 IS 锁或 S 锁，但不能获取排他锁（X 锁）。
     - Intention Exclusive Locks (IX): 这种锁表示事务打算在表的某个部分上获取一个排他锁（X 锁）。其他事务可以同时获取该表的 IS 锁，但不能获取 IX 锁、S 锁或 X 锁。
   - **自动增量锁（AUTO-INC Locks）**：这种锁用于保护包含自动增量列（AUTO_INCREMENT）的表。当一个事务正在插入新的行时，MySQL 会获取自动增量锁，确保自增列的值是唯一的。

3. **行级锁**：仅对表中的特定行加锁，分为以下几种：

   - **共享锁 S（Shared Locks）**：也被称为读锁，允许一个事务读取一行数据。其他事务可以同时获得同一行数据的读锁，但任何事务都不能获得写锁，直到已经持有的所有读锁都被释放。
   - **排他锁 X（Exclusive Locks）**：也被称为写锁，允许一个事务更新一行数据。只有当没有其他事务持有该行数据的读锁或写锁时，一个事务才能获得写锁。
   - **记录锁（Record Locks）**：这种锁是对单个行记录的锁定。
   - **间隙锁（Gap Locks）**：这种锁锁定一个范围，但不包括记录本身。它用于防止多个事务同时插入到同一位置。
   - **临键锁（Next-Key Locks）**：这是记录锁和间隙锁的组合，锁定一个范围并包括记录本身。

4. **页级锁**：锁定一组连续的记录，介于表锁和行锁之间。BDB 存储引擎支持页级锁。

**按锁的类型划分：**

1. **共享锁 (S)**：也称为读锁，允许多个事务同时读取同一资源。
2. **排他锁 (X)**：也称为写锁，只允许一个事务写入资源，其他事务无法访问。
3. **意向锁 (IS, IX)**：表明事务打算在表中的行上获取哪种类型的锁。IS 表示意向共享锁，IX 表示意向排他锁。

**按加锁方式划分：**

1. **自动锁（Automatic Acquisition）**：MySQL 会根据 SQL 语句自动添加适当的锁。
2. **显式锁**:用户可以使用 `LOCK TABLES`、`SELECT ... LOCK IN SHARE MODE`、`SELECT ... FOR UPDATE` 等语句显式加锁。

**如何选择合适的锁：**

- **全局锁**：很少使用，除非需要对整个数据库进行独占操作。
- **表级锁**：适用于并发写入较少的场景，或者需要对整张表进行操作。
- **行级锁**：适用于高并发写入的场景，可以提高并发性能。
- **页级锁**：一般不常用，除非使用 BDB 存储引擎。

MySQL 锁机制：

1. **基本原则 1**：MySQL 中的基本加锁单位是 next-key 锁。这种锁的范围是前开后闭区间，也就是说锁住的范围包括起始点之后，但不包括终止点。
2. **基本原则 2**：在查询过程中，只有实际访问到的对象才会被加锁。
3. **优化 1**：在唯一索引上的等值查询中，next-key 锁会退化为行锁，只锁住具体的行。
4. **优化 2**：在索引上的等值查询中，如果向右遍历时，遇到的最后一个值不满足等值条件，next-key 锁会简化为间隙锁，只锁住间隙，不锁具体的行。
5. ~~**一个 Bug**：在唯一索引上的范围查询中，锁会一直加到第一个不满足条件的值为止，即使这个值本身并不符合查询条件。~~

参考和引用

- https://dev.mysql.com/doc/refman/8.4/en/lock-tables.html
- https://dev.mysql.com/doc/refman/8.4/en/internal-locking.html
- https://dev.mysql.com/doc/refman/8.4/en/innodb-locking.html
- https://stackoverflow.com/questions/39148282/what-are-mysql-innodb-intention-locks-used-for
- [MySQL 实战 45 讲](https://time.geekbang.org/column/intro/100020801)

## 数据库在分布式锁中的两种实现方式

### 通过表中记录的存在情况确定当前是否有锁存在

**基本原理：**

- **锁表：** 创建一张专门用于存放锁信息的表（例如 `locks`），通常包含 `lock_name` (锁的名称) 和 `lock_owner` (锁的持有者) 等字段。
- **获取锁：** 当应用需要获取锁时，尝试在 `locks` 表中插入一条记录，`lock_name` 为锁的名称，`lock_owner` 为当前应用的标识。如果插入成功，表示获取锁成功；如果插入失败（通常由于唯一键约束冲突），表示锁已被其他应用持有。
- **释放锁：** 当应用不再需要锁时，删除 `locks` 表中对应的记录。

**示例 (MySQL)：**

```sql
-- 创建锁表
CREATE TABLE locks (
    lock_name VARCHAR(255) PRIMARY KEY,
    lock_owner VARCHAR(255)
);

-- 获取锁 (假设锁名为 'my_lock'，应用标识为 'app1')
INSERT INTO locks (lock_name, lock_owner) VALUES ('my_lock', 'app1');

-- 释放锁
DELETE FROM locks WHERE lock_name = 'my_lock';
```

**优点：**

- 简单易实现。
- 不需要额外的组件或服务。

**缺点：**

- **性能问题：** 在高并发场景下，频繁的插入和删除操作可能导致数据库性能瓶颈。
- **死锁风险：** 如果应用在持有锁期间异常崩溃，锁记录可能无法被删除，导致死锁。需要额外的机制（如超时机制）来解决。
- **单点故障：** 数据库本身可能成为单点故障。

### 通过数据库的排他锁来实现分布式锁

**基本原理：**

- **获取锁：** 当应用需要获取锁时，执行一条带有 `FOR UPDATE` 语句的查询操作，例如 `SELECT * FROM locks WHERE lock_name = 'my_lock' FOR UPDATE;`。这条语句会对查询到的记录加排他锁，其他事务无法再对该记录加锁，直到当前事务提交或回滚。
- **释放锁：** 当应用不再需要锁时，提交或回滚当前事务，释放排他锁。

**示例 (MySQL)：**

```sql
-- 获取锁
BEGIN; -- 开始事务
SELECT * FROM locks WHERE lock_name = 'my_lock' FOR UPDATE;
-- ... 执行需要锁保护的操作 ...
COMMIT; -- 提交事务，释放锁
```

**优点：**

- 利用数据库的锁机制，实现简单。
- 死锁问题较少。

**缺点：**

- **性能问题：** 排他锁会阻塞其他事务，在高并发场景下可能影响数据库性能。
- **数据库依赖：** 强依赖于数据库的锁机制。
- **单点故障：** 数据库本身可能成为单点故障。

**总结**

数据库可以用于实现分布式锁，但通常不作为首选方案。在实际应用中，更推荐使用专门的分布式锁组件或服务，如 Redis、ZooKeeper、etcd 等，它们提供了更丰富的功能和更高的性能。
