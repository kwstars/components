## WebSocket URIs

**URI schemes**：

- `ws:` 用于未加密的 WebSocket 连接（默认端口 80）。
- `wss:` 用于加密的 WebSocket 连接（默认端口 443）。

**URI 格式**：

```
ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]
wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]
```

其中：

- `host:` 主机名（域名或 IP 地址）。
- `port:` 可选，端口号。
- `path:` 路径（可以为空）。
- `query:` 可选，查询参数。

**其他**：

- 端口号默认为 `ws` 是 80，`wss` 是 443。
- 资源名称（resource-name）由 `/` + `path` + `?` + `query` (如果有) 构成。
- 片段标识符（fragment identifiers）在 WebSocket URIs 中无意义，不得使用。
- `#` 字符在不表示片段标识符时必须转义为 `%23`。

**示例**：

- `ws://example.com/chat`
- `wss://example.com:8443/securechat?room=general`

## Opening Handshake

### Client Requirements

WebSocket 客户端握手要求总结：

**WebSocket URI**：

1.  客户端必须提供有效的 WebSocket URI，包括主机名 (`host`)、端口号 (`port`)、资源名称 (`resource name`) 和安全标识 (`secure` flag)。

**连接建立**：

2.  客户端必须等待与同一主机和端口的现有连接建立或失败后，才能发起新的连接。
3.  如果配置了代理，客户端应该通过代理连接到目标主机和端口。
4.  如果无法打开连接（直接连接失败或代理返回错误），客户端必须终止连接尝试。

**TLS 握手 (如果 secure 为 true)**：

5.  客户端必须在发送握手数据之前，通过连接执行 TLS 握手。如果握手失败（例如，无法验证服务器证书），客户端必须终止连接。
6.  客户端必须在 TLS 握手期间使用服务器名称指示 (SNI) 扩展。

**握手请求**：

1.  握手必须是有效的 HTTP 请求。
2.  请求方法必须为 GET，HTTP 版本必须至少为 1.1。
3.  请求的 `Request-URI` 部分必须与定义的 `resource name` 匹配，或者是一个解析后具有匹配的 `resource name`、`host` 和 `port` 的绝对 http/https URI。
4.  请求必须包含一个 `Host` 头字段，其值包含 `host`，可选地后跟 `:` 和 `port`（当不使用默认端口时）。
5.  请求必须包含一个值为 "websocket" 的 `Upgrade` 头字段。
6.  请求必须包含一个包含 "Upgrade" token 的 `Connection` 头字段。
7.  请求必须包含一个名为 `Sec-WebSocket-Key` 的头字段，其值为随机选择的 16 字节值的 base64 编码。
8.  如果请求来自浏览器客户端，则请求必须包含一个 `Origin` 头字段。
9.  请求必须包含一个值为 13 的 `Sec-WebSocket-Version` 头字段。
10. 请求可以包含一个 `Sec-WebSocket-Protocol` 头字段，指示客户端希望使用的子协议。
11. 请求可以包含一个 `Sec-WebSocket-Extensions` 头字段，指示客户端希望使用的协议级扩展。
12. 在 WebSocket 握手过程中，除了 RFC 6455 中明确要求的那些头字段外，客户端还可以发送其他任意的 HTTP 头字段。这些额外的头字段的处理方式取决于它们各自的规范。

**握手响应验证**：

1.  如果从服务器收到的状态代码不是 101，则客户端按照 HTTP 程序处理响应。
2.  如果响应缺少 `Upgrade` 头字段，或者 `Upgrade` 头字段的值不是 "websocket"，则客户端必须终止连接。
3.  如果响应缺少 `Connection` 头字段，或者 `Connection` 头字段不包含 "Upgrade"，则客户端必须终止连接。
4.  如果响应缺少 `Sec-WebSocket-Accept` 头字段，或者 `Sec-WebSocket-Accept` 的值不是 `Sec-WebSocket-Key` 与字符串 "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" 连接后的 base64 编码 SHA-1 值，则客户端必须终止连接。
5.  如果响应包含 `Sec-WebSocket-Extensions` 头字段，并且该字段指示使用了客户端握手时未提供的扩展，则客户端必须终止连接。
6.  如果响应包含 `Sec-WebSocket-Protocol` 头字段，并且该字段指示使用了客户端握手时未提供的子协议，则客户端必须终止连接。

**注意**： 所有 HTTP 请求和响应中的头字段名称都不区分大小写。

### Server-Side Requirements

#### Reading the Client's Opening Handshake

服务器必须解析客户端的握手请求，以获取生成服务器握手响应所需的信息。如果客户端发送的握手不符合以下描述，服务器必须停止处理并返回适当的错误代码（例如 400 Bad Request）。

**客户端握手请求组成部分**：

1.  **GET 请求**： 使用 HTTP/1.1 或更高版本的 GET 请求，包括一个 `Request-URI`，该 URI 应被解释为第 3 节中定义的资源名称（或者包含资源名称的绝对 HTTP/HTTPS URI）。
2.  **Host 头字段**： 包含服务器的权限。
3.  **Upgrade 头字段**： 包含值 "websocket"，不区分大小写。
4.  **Connection 头字段**： 包含 "Upgrade" token，不区分大小写。
5.  **Sec-WebSocket-Key 头字段**： 包含 base64 编码的值，解码后长度为 16 字节。
6.  **Sec-WebSocket-Version 头字段**： 值为 13。
7.  **(可选) Origin 头字段**： 所有浏览器客户端都会发送此字段，缺少此字段的连接尝试不应被视为来自浏览器客户端。
8.  **(可选) Sec-WebSocket-Protocol 头字段**： 包含一个值列表，指示客户端希望使用的协议，按优先级排序。
9.  **(可选) Sec-WebSocket-Extensions 头字段**： 包含一个值列表，指示客户端希望使用的扩展。
10. **(可选) 其他头字段**： 例如用于发送 cookie 或向服务器请求身份验证的头字段。未知的头字段将被忽略。

**要点**：

- 服务器必须按照 RFC 2616 和 RFC 6455 中指定的 ABNF 语法解析客户端的握手请求。
- 服务器必须验证所有必需的头字段是否存在且格式正确。
- 服务器可以忽略任何未知或不受支持的可选头字段。
- 如果客户端握手请求无效，服务器必须返回适当的错误代码。

#### Sending the Server's Opening Handshake

当客户端建立 WebSocket 连接时，服务器必须完成以下步骤来接受连接并发送服务器握手响应。

**步骤**：

1.  **(HTTPS 连接) TLS 握手**： 如果连接发生在 HTTPS 端口上，服务器必须执行 TLS 握手。如果握手失败，服务器必须关闭连接。

2.  **(可选) 客户端认证**： 服务器可以执行额外的客户端认证，例如通过返回 401 状态码和 `WWW-Authenticate` 头字段。

3.  **(可选) 重定向**： 服务器可以使用 3xx 状态码重定向客户端。

4.  **收集信息**：

    - `origin`：来自客户端握手 `Origin` 头字段的值。
    - `key`：来自客户端握手 `Sec-WebSocket-Key` 头字段的值。
    - `version`：来自客户端握手 `Sec-WebSocket-Version` 头字段的值。
    - `resource name`：标识服务器提供的服务。
    - `subprotocol`：服务器准备使用的子协议（可以为 null）。
    - `extensions`：服务器准备使用的协议级扩展列表（可以为空）。

5.  **发送握手响应**： 如果服务器选择接受连接，它必须发送一个有效的 HTTP 响应，包括：
    - **101 状态码**： 表示切换协议。
    - **Upgrade 头字段**： 值为 "websocket"。
    - **Connection 头字段**： 值为 "Upgrade"。
    - **Sec-WebSocket-Accept 头字段**： 将 `key` 与字符串 "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" 连接，进行 SHA-1 哈希，然后 base64 编码得到的值。
    - **(可选) Sec-WebSocket-Protocol 头字段**： 服务器同意的子协议。
    - **(可选) Sec-WebSocket-Extensions 头字段**： 服务器同意的扩展。

**完成握手**：

如果服务器完成这些步骤而没有中止 WebSocket 握手，则服务器认为 WebSocket 连接已建立并处于 OPEN 状态。此时，服务器可以开始发送和接收数据。

## Data Framing

WebSocket 协议通过一系列帧来传输数据，所有从客户端发送到服务器的帧都必须进行掩码处理以增强安全性，无论是否通过 TLS 运行。如果服务器接收到未经掩码处理的帧，它必须关闭连接，并可以发送一个状态码为 1002（协议错误）的关闭帧。另一方面，从服务器发送到客户端的帧不应进行掩码处理，如果客户端检测到经过掩码处理的帧，它也必须关闭连接，并可以使用状态码 1002。

WebSocket 帧由以下部分组成：

- 操作码（opcode）：定义帧的类型。
- 负载长度（payload length）：指示应用数据的长度。
- 扩展数据（Extension data）：供扩展使用。
- 应用数据（Application data）：实际传输的数据。

负载数据（Payload data）由扩展数据和应用数据组成。

```
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+-------------+-------------------------------+
     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
     |N|V|V|V|       |S|             |   (if payload len==126/127)   |
     | |1|2|3|       |K|             |                               |
     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     |     Extended payload length continued, if payload len == 127  |
     + - - - - - - - - - - - - - - - +-------------------------------+
     |                               |Masking-key, if MASK set to 1  |
     +-------------------------------+-------------------------------+
     | Masking-key (continued)       |          Payload Data         |
     +-------------------------------- - - - - - - - - - - - - - - - +
     :                     Payload Data continued ...                :
     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     |                     Payload Data continued ...                |
     +---------------------------------------------------------------+
```

- FIN（1 位）：指示是否为消息的最后一帧。
- RSV1、RSV2、RSV3（各 1 位）：必须为 0，除非协商了具有非零值含义的扩展。
- Opcode（4 位）：定义“负载数据”的解释方式。
  - %x0：延续帧（a continuation frame）
  - %x1：文本帧（a text frame）
  - %x2：二进制帧（a binary frame）
  - %x3-7：保留给未来的非控制帧
  - %x8：连接关闭（a connection close）
  - %x9：ping
  - %xA：pong
  - %xB-F：保留给未来的控制帧
- Mask（1 位）：定义“负载数据”是否被掩码。
  - 1：已掩码，存在 masking-key
  - 0：未掩码，无 masking-key
- Payload length（7、7+16 或 7+64 位）：负载数据的长度（字节）。
  - 0-125：直接表示长度
  - 126：后 2 字节为 16 位无符号整数表示长度
  - 127：后 8 字节为 64 位无符号整数表示长度
- Masking-key（0 或 4 字节）：
  - 仅当 Mask 为 1 时存在
  - 客户端发送到服务器的所有帧都必须包含掩码密钥
- Payload data（x+y 字节）：
  - Extension data + Application data

如何解析 Extended Payload Length？

1. 读取 Payload Length 字段的值。
2. 如果值为 0-125，则该值为负载数据长度。
3. 如果值为 126，则读取接下来的 2 个字节，将其解释为 16 位无符号整数，即为负载数据长度。
4. 如果值为 127，则读取接下来的 8 个字节，将其解释为 64 位无符号整数（最高位必须为 0），即为负载数据长度。

假设一个 WebSocket 帧的 Payload Length 为 126，接下来的 2 个字节为 0x01 0x00。则负载数据的长度为 256 字节（0x0100）。

### Client-to-Server Masking

**目的**：

- 增强安全性，防止恶意应用选择传输内容：掩码处理可以防止恶意应用利用 WebSocket 协议来进行某些特定的网络攻击。例如，如果没有掩码处理，恶意应用可能会选择发送某些特定的数据包，以试图欺骗网络中介（如代理服务器）或者触发网络设备的某些特定行为。通过对所有数据帧进行掩码处理，可以确保发送的数据包的内容是随机的，从而防止这种攻击。
- 避免混淆网络中介（如代理服务器）：在某些情况下，如果网络中介（如代理服务器）看到的是未经掩码处理的 WebSocket 数据帧，它可能会误认为这些数据帧是普通的 HTTP 流量，从而进行错误的处理。通过对所有数据帧进行掩码处理，可以确保网络中介能够正确地识别 WebSocket 流量。

**掩码要求**：

- 发送到服务器的帧必须设置 `frame-masked` 为 1。
- 掩码密钥（masking key）是一个 32 位随机值，包含在帧内。
- 每个帧必须使用新的随机掩码密钥。
- 掩码密钥必须来自强熵源，不可预测。

**掩码算法**：

- 对负载数据（Payload data）进行转换，不影响其长度。
- 转换后的第 i 个字节 = 原始数据的第 i 个字节 XOR 掩码密钥的第 (i MOD 4) 个字节。

**注意**：

- 负载长度（`frame-payload-length`）不包括掩码密钥的长度。

**示例**：

假设掩码密钥为 0x37fa213d，对负载数据 "Hello" 进行掩码：

```
H        e        l        l        o
0x48     0x65     0x6c     0x6c     0x6f
XOR      XOR      XOR      XOR      XOR
0x37     0xfa     0x21     0x3d     0x37
----------------------------------------
0x7f     0x9f     0x4d     0x51     0x58
```

转换后的数据为 0x7f 0x9f 0x4d 0x51 0x58。

### Fragmentation

**主要目的**：

- 允许在开始发送消息时不知道消息大小的情况下发送消息，而无需缓冲整个消息。

**次要目的**：

- 多路复用，避免单个逻辑信道上的大消息独占输出信道。

**分片规则**：

- **未分片消息**： 包含一个 FIN 位已设置且操作码不为 0 的帧。
- **分片消息**：
  - 第一个帧：FIN 位清除，操作码不为 0。
  - 中间帧：FIN 位清除，操作码为 0。
  - 最后一个帧：FIN 位设置，操作码为 0。
- **控制帧**：
  - 可以插入分片消息中间。
  - 不能被分片。
- **消息顺序**： 必须按照发送顺序传递。
- **消息交错**： 除非协商了可以解释交错的扩展，否则不能交错不同消息的片段。
- **控制帧处理**： 必须能够处理分片消息中间的控制帧。
- **分片大小**： 对于非控制消息，可以创建任意大小的片段。
- **接收支持**： 客户端和服务器必须支持接收分片和未分片消息。
- **中介限制**：
  - 不得更改控制帧的分片。
  - 如果使用了保留位值且不知道其含义，则不得更改消息的分片。
  - 如果协商了扩展但不知道扩展的语义，则不得更改消息的分片。
  - 如果未看到 WebSocket 握手，则不得更改任何消息的分片。

**类型一致性**：

- 由于控制帧不能分片，因此消息中的所有片段必须是文本、二进制或保留的操作码之一。

**实现注意事项**：

- 在没有扩展的情况下，接收器无需缓冲整个帧即可处理它。

### Control Frames

WebSocket 协议中的控制帧用于传递连接状态信息，可以插入到分片消息中间，且所有控制帧的负载长度必须小于等于 125 字节，并且不能被分片。目前定义的控制帧操作码包括：0x8 (Close)，用于关闭连接；0x9 (Ping)，用于检查连接是否仍然有效；以及 0xA (Pong)，用于响应 Ping 帧。

**关闭帧 (Close)**：

- 操作码为 0x8。
- 可以包含一个 body，指示关闭原因（如端点关闭、收到过大帧、格式错误等）。
- body 的前 2 个字节为状态码，后跟可选的 UTF-8 编码数据（原因）。
- 从客户端发送到服务器的关闭帧必须掩码。
- 发送关闭帧后不能再发送数据帧。
- 收到关闭帧的一方必须回复一个关闭帧。
- 双方发送和接收关闭帧后，应关闭底层 TCP 连接。

**Ping 帧**：

- 操作码为 0x9。
- 可以包含应用数据。
- 收到 Ping 帧的一方必须回复 Pong 帧。
- Ping 帧可在连接建立后、关闭前随时发送。

**Pong 帧**：

- 操作码为 0xA。
- 用于响应 Ping 帧，其应用数据必须与 Ping 帧相同。
- 可以不请自来，作为单向心跳。

**注意**：

- Ping 帧可以作为保活或验证远程端点是否响应的手段。
- 如果收到多个 Ping 帧，可以选择只回复最后一个。

### Data Frames

WebSocket 协议中的数据帧用于传输应用层和/或扩展层的数据，其操作码（opcode）的最高位为 0。目前定义的操作码包括：0x1，表示文本数据帧；和 0x2，表示二进制数据帧。

**文本帧 (Text)**：

- 负载数据是 UTF-8 编码的文本数据。
- 单个文本帧可能包含部分 UTF-8 序列，但整个消息必须包含有效的 UTF-8。
- 重组消息中的无效 UTF-8 处理方式。

**二进制帧 (Binary)**：

- 负载数据是任意二进制数据，其解释由应用层决定。

**注意**：

- 操作码 0x3-0x7 保留给未来定义的非控制帧。

## Closing the Connection

客户端关闭连接：

- 除非应用层指定，否则客户端不应关闭连接。
- 在握手期间或底层连接意外丢失时，客户端必须关闭连接。

服务器关闭连接：

- 服务器可以随时关闭连接。
- 在握手期间，服务器可能需要中止连接。

## 参考和引用

- [WebSocket: Lightweight Client-Server Communications](https://github.com/kinabalu/websocketsbook)
- https://github.com/facundofarias/awesome-websockets
- https://datatracker.ietf.org/doc/html/rfc6455
